/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package org.openjdk.jmh.profile;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import joptsimple.OptionSpec;
import org.openjdk.jmh.infra.BenchmarkParams;
import org.openjdk.jmh.results.*;
import org.openjdk.jmh.util.FileUtils;
import org.openjdk.jmh.util.TempFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
 * macOS perfnorm profiler based on xctrace utility shipped with Xcode Instruments.
 * Depending on the chosen tracing configuration, so-called template, xctrace may sample PMU counters
 * using either timer interrupts, or PMU interrupts.
 * <p>
 * The profiling process consists of several steps:
 * 1) launching a program that needs to be profiled using `xctrace record` command; in case of success,
 * the output of this step is a "trace-file", which is in fact a directory containing multiple files
 * representing the recorded trace, the trace may contain multiple resulting tables, depending on the template;
 * 2) inspecting a recorded trace to check if it contains a table supported by the profiler; this information
 * could be obtained from the trace's table of contents (`xctrace export --toc`);
 * 3) extracting the table with profiling results from the trace file using `xctrace export` and parsing it
 * to extract individual samples.
 * <p>
 * `xctrace export` extracts data only in XML format, thus both the table of contents and the table
 * with profiling results need to be parsed as XML documents.
 * <p>
 * This profiler currently supports only one table type: counters-profile.
 * Such tables are generated by the CPU Counters instrument performing sampling either by
 * timer interrupts, or interrupts generated by a PMU counter, depending on particular configuration.
 * <p>
 * Tracing configuration, or template, mentioned earlier is a file that could be configured and saved
 * using Instruments application. Unfortunately, there is no other way to set it up.
 * <p>
 * There's no builtin template that could be used with this profiler, thus the template had to be configured and saved
 * by a user before running the profiler.
 * <p>
 * TODO:
 * - support other instruments to collect information about virtual memory, context switches, etc.
 */
public class XCTraceNormProfiler implements ExternalProfiler {
    private static final XCTraceTableHandler.ProfilingTableType SUPPORTED_TABLE_TYPE
            = XCTraceTableHandler.ProfilingTableType.COUNTERS_PROFILE;
    // Counter names may vary depending on particular CPU,
    // but these names are the most popular (see files in /usr/share/kpep).
    // On Arm-based CPUs names (in fact, aliases) are usually Instructions and Cycles,
    // on x86-64 CPUs names are usually INST_ALL and ReferenceCycles.
    private static final String[] INSTRUCTIONS_COUNTERS = new String[]{
            "Instructions", "FIXED_INSTRUCTIONS", "INST_ALL"
    };
    private static final String[] CYCLES_COUNTERS = new String[]{
            "Cycles", "ReferenceCycles", "FIXED_CYCLES", "CORE_ACTIVE_CYCLE"
    };
    private final String tracingTemplate;
    private final Path temporaryFolder;
    private final Path pkgDir;
    private final TempFile outputFile;

    private final long delayMs;
    private final long lengthMs;
    private final boolean shouldFixStartTime;

    public XCTraceNormProfiler(String initLine) throws ProfilerException {
        OptionParser parser = new OptionParser();
        parser.formatHelpWith(new ProfilerOptionFormatter(XCTraceNormProfiler.class.getName()));

        OptionSpec<String> templateOpt = parser.accepts("template", "Name of or path to Instruments template. " +
                        "Use `xctrace list templates` to view available templates. " +
                        "Only templates with \"CPU Counters\" instrument are supported at the moment.")
                .withRequiredArg().ofType(String.class);
        OptionSpec<Integer> optDelay = parser.accepts("delay",
                        "Delay collection for a given time, in milliseconds; -1 to detect automatically.")
                .withRequiredArg().ofType(Integer.class).describedAs("ms").defaultsTo(-1);
        OptionSpec<Integer> optLength = parser.accepts("length",
                        "Do the collection for a given time, in milliseconds; -1 to detect automatically.")
                .withRequiredArg().ofType(Integer.class).describedAs("ms").defaultsTo(-1);
        OptionSpec<Boolean> correctOpt = parser.accepts("fixStartTime",
                        "Fix the start time by the time it took to launch.")
                .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
        OptionSpec<String> pmcEventsOpt = parser.accepts("pmcEvents",
                        "Comma-separated list of PMC events to sample.")
                .withOptionalArg().ofType(String.class);

        OptionSet options = ProfilerUtils.parseInitLine(initLine, parser);
        tracingTemplate = options.valueOf(templateOpt);
        delayMs = options.valueOf(optDelay);
        lengthMs = options.valueOf(optLength);
        shouldFixStartTime = options.valueOf(correctOpt);
        List<String> pmcEvents = Collections.emptyList();
        if (options.hasArgument(pmcEventsOpt)) {
            pmcEvents = Stream.of(options.valueOf(pmcEventsOpt).split(","))
                    .map(String::trim)
                    .filter(e -> !e.isEmpty())
                    .collect(Collectors.toList());
        }

        if (!pmcEvents.isEmpty()) {
            pkgDir = XCTraceSupport.createTemporaryDirectoryName().resolve("instr.instrdst");
            pkgDir.toFile().getParentFile().mkdirs();
            XCTraceSupport.buildSamplerPackage(10, pmcEvents, pkgDir);
        } else {
            pkgDir = null;
        }

        XCTraceSupport.checkXCTraceWorks();

        try {
            temporaryFolder = XCTraceSupport.createTemporaryDirectoryName();
            outputFile = FileUtils.weakTempFile("xctrace-out.xml");
        } catch (IOException e) {
            throw new ProfilerException(e.getMessage());
        }
    }

    private static XCTraceTableHandler.XCTraceTableDesc findTableDescription(XCTraceTableOfContentsHandler tocHandler) {
        XCTraceTableHandler.XCTraceTableDesc tableDesc = tocHandler.getSupportedTables()
                .stream()
                .filter(t -> t.getTableType() == SUPPORTED_TABLE_TYPE)
                .findFirst()
                .orElseThrow(() -> new IllegalStateException("Table \"" + SUPPORTED_TABLE_TYPE.tableName +
                        "\" was not found in the trace results."));
        if (tableDesc.counters().isEmpty() && tableDesc.getTriggerType() == XCTraceTableHandler.TriggerType.TIME) {
            throw new IllegalStateException("Results does not contain any events.");
        }
        return tableDesc;
    }

    @Override
    public Collection<String> addJVMInvokeOptions(BenchmarkParams params) {
        if (pkgDir == null) {
            return XCTraceSupport.recordCommandPrefix(temporaryFolder.toAbsolutePath().toString(),
                    null, tracingTemplate);
        }
        List<String> args = new ArrayList<>();
        Collections.addAll(args, "xctrace", "record",
                "--package", pkgDir.toAbsolutePath().toString(),
                "--instrument", "XCTraceNormProfiler",
                "--output", temporaryFolder.toAbsolutePath().toString(), "--target-stdout", "-", "--launch", "--");
        return args;
    }

    @Override
    public Collection<String> addJVMOptions(BenchmarkParams params) {
        return Collections.emptyList();
    }

    @Override
    public void beforeTrial(BenchmarkParams benchmarkParams) {
        temporaryFolder.toFile().mkdirs();
    }

    @Override
    public Collection<? extends Result> afterTrial(BenchmarkResult br, long pid, File stdOut, File stdErr) {
        try {
            return processResults(br);
        } finally {
            XCTraceSupport.removeDirectory(temporaryFolder);
        }
    }

    private Collection<? extends Result> processResults(BenchmarkResult br) {
        BenchmarkResultMetaData md = br.getMetadata();
        if (md == null) {
            return Collections.emptyList();
        }
        long measurementsDurationMs = md.getStopTime() - md.getMeasurementTime();
        if (measurementsDurationMs == 0L) {
            return Collections.emptyList();
        }
        double opsThroughput = md.getMeasurementOps() / (double) measurementsDurationMs;

        Path traceFile = XCTraceSupport.findTraceFile(temporaryFolder);
        XCTraceSupport.exportTableOfContents(traceFile.toAbsolutePath().toString(), outputFile.getAbsolutePath());

        XCTraceTableOfContentsHandler tocHandler = new XCTraceTableOfContentsHandler();
        tocHandler.parse(outputFile.file());
        XCTraceTableHandler.XCTraceTableDesc tableDesc = findTableDescription(tocHandler);
        XCTraceSupport.exportTable(traceFile.toAbsolutePath().toString(), outputFile.getAbsolutePath(),
                SUPPORTED_TABLE_TYPE);

        /*
         * BenchmarkResultMetaData captures the time when a fork was launched.
         * xctrace saves timestamps relative to the start of the tracing process.
         * It may take a considerable time to start xctrace (up to several seconds in some cases), so we
         * can't directly use measurementDelayMs.
         * However, xctrace trace's table of contents contains the timestamp corresponding to
         * the actual traced process start time. It could be used to correct measurementDelayMs.
         *
         *               /<-- delta -->/
         *              /             /
         *  time -------|-------------|------------------------------|----------->
         *              |             |                              |
         *       *fork launched*      |                     *measurements started*
         *        getStartTime()      |                      getMeasurementTime()
         *                      xctrace started java
         *                    tocHandler.getRecordStartMs()
         */
        long timeCorrectionMs = 0;
        if (shouldFixStartTime) {
            timeCorrectionMs = tocHandler.getRecordStartMs() - md.getStartTime();
        }
        long skipMs = delayMs;
        if (skipMs == -1L) {
            skipMs = ProfilerUtils.measurementDelayMs(br);
        }
        skipMs -= timeCorrectionMs;
        long durationMs = lengthMs;
        if (durationMs == -1L) {
            durationMs = ProfilerUtils.measuredTimeMs(br);
        }

        long skipNs = skipMs * 1000000;
        long durationNs = durationMs * 1000000;

        AggregatedEvents aggregator = new AggregatedEvents(tableDesc);
        new XCTraceTableProfileHandler(SUPPORTED_TABLE_TYPE, sample -> {
            if (sample.getTimeFromStartNs() <= skipNs || sample.getTimeFromStartNs() > skipNs + durationNs) {
                return;
            }

            aggregator.add(sample);
        }).parse(outputFile.file());

        if (aggregator.eventsCount == 0) {
            return Collections.emptyList();
        }

        Collection<Result<?>> results = new ArrayList<>();
        {
            Double insts = null;
            String instsName = null;
            for (String name : INSTRUCTIONS_COUNTERS) {
                if ((insts = aggregator.getCountOrNull(name)) != null) {
                    instsName = name;
                    break;
                }
            }
            Double cycles = null;
            String cyclesName = null;
            for (String name : CYCLES_COUNTERS) {
                if ((cycles = aggregator.getCountOrNull(name)) != null) {
                    cyclesName = name;
                    break;
                }
            }
            if (insts != null && cycles != null && insts != 0.0 && cycles != 0.0) {
                results.add(new ScalarResult("CPI", cycles / insts,
                        cyclesName + "/" + instsName, AggregationPolicy.AVG));
                results.add(new ScalarResult("IPC", insts / cycles,
                        instsName + "/" + cyclesName, AggregationPolicy.AVG));
            }
        }

        aggregator.normalizeByThroughput(opsThroughput);

        for (int i = 0; i < tableDesc.counters().size(); i++) {
            String event = tableDesc.counters().get(i);
            results.add(new ScalarResult(event, aggregator.eventValues[i],
                    "#/op", AggregationPolicy.AVG));
        }
        if (tableDesc.getTriggerType() == XCTraceTableHandler.TriggerType.PMI) {
            results.add(new ScalarResult(tableDesc.triggerEvent(),
                    aggregator.eventValues[aggregator.eventValues.length - 1],
                    "#/op", AggregationPolicy.AVG));
        }
        return results;
    }

    @Override
    public boolean allowPrintOut() {
        return true;
    }

    @Override
    public boolean allowPrintErr() {
        return false;
    }

    @Override
    public String getDescription() {
        return "macOS xctrace (Instruments) PMU counter statistics, normalized by operation count";
    }

    private static class AggregatedEvents {
        final List<String> eventNames;
        final double[] eventValues;
        long eventsCount = 0;

        long minTimestampMs = Long.MAX_VALUE;
        long maxTimestampMs = Long.MIN_VALUE;

        public AggregatedEvents(XCTraceTableHandler.XCTraceTableDesc tableDesc) {
            List<String> names = new ArrayList<>(tableDesc.counters());
            names.add(tableDesc.triggerEvent());
            eventNames = Collections.unmodifiableList(names);
            eventValues = new double[eventNames.size()];
        }

        void add(XCTraceTableProfileHandler.XCTraceSample sample) {
            long[] counters = sample.getPmcCounters();
            for (int i = 0; i < counters.length; i++) {
                eventValues[i] += counters[i];
            }
            eventValues[eventValues.length - 1] = sample.getWeight();
            minTimestampMs = Math.min(minTimestampMs, sample.getTimeFromStartNs());
            maxTimestampMs = Math.max(maxTimestampMs, sample.getTimeFromStartNs());
            eventsCount++;
        }

        void normalizeByThroughput(double throughput) {
            if (maxTimestampMs == minTimestampMs) {
                throw new IllegalStateException("Min and max timestamps are the same.");
            }
            double timeSpanMs = (maxTimestampMs - minTimestampMs) / 1e6;
            for (int i = 0; i < eventValues.length; i++) {
                eventValues[i] = eventValues[i] / timeSpanMs / throughput;
            }
        }

        Double getCountOrNull(String event) {
            int idx = eventNames.indexOf(event);
            if (idx == -1) return null;
            return eventValues[idx];
        }
    }
}
